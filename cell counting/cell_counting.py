# -*- coding: utf-8 -*-
"""cell counting.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Bx6VocPdMrXZaxg4yGAEafsiPoYZbs-L
"""

from google.colab.patches import cv2_imshow
import cv2
import numpy as np

def count_cells(image_path):
    # Read the image
    image = cv2.imread(image_path)

    # Convert the image to grayscale
    gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)

    # Apply Gaussian blur to reduce noise
    blurred = cv2.GaussianBlur(gray, (11, 11), 0)

    # Threshold the image to get a binary image
    _, thresh = cv2.threshold(blurred, 200, 255, cv2.THRESH_BINARY)

    # Find contours in the binary image
    contours, _ = cv2.findContours(thresh.copy(), cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)

    # Draw contours on the original image (for visualization)
    cv2.drawContours(image, contours, -1, (0, 255, 0), 2)

    # Count the number of contours (cells)
    num_cells = len(contours)

    # Display the result
    cv2.putText(image, f'Cells: {num_cells}', (10, 30), cv2.FONT_HERSHEY_SIMPLEX, 0.8, (0, 0, 255), 2)
    cv2_imshow(image)

    return num_cells

# Example usage
image_path = 'cell.jpg'
num_cells = count_cells(image_path)
print(f'Number of cells: {num_cells}')

from google.colab.patches import cv2_imshow

!curl -o logo.png https://colab.research.google.com/img/colab_favicon_256px.png
import cv2
img = cv2.imread('cell.jpg', cv2.IMREAD_UNCHANGED)
cv2_imshow(img)

from google.colab.patches import cv2_imshow
import cv2
import numpy as np

def preprocess_image(image_path):
    # Read the image
    image = cv2.imread(image_path)

    # Convert the image to grayscale
    gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)

    # Denoising
    denoised = cv2.fastNlMeansDenoising(gray, None, h=10, templateWindowSize=7, searchWindowSize=21)

    # Smoothing
    blurred = cv2.GaussianBlur(denoised, (11, 11), 0)

    # Histogram Equalization
    equalized = cv2.equalizeHist(blurred)

    return equalized

def count_cells(image):
    # Threshold the preprocessed image to get a binary image
    _, thresh = cv2.threshold(image, 200, 255, cv2.THRESH_BINARY)

    # Find contours in the binary image
    contours, _ = cv2.findContours(thresh.copy(), cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)

    # Draw contours on the original image (for visualization)
    result_image = cv2.cvtColor(image, cv2.COLOR_GRAY2BGR)  # Convert grayscale image to color for drawing contours
    cv2.drawContours(result_image, contours, -1, (0, 255, 0), 2)

    # Count the number of contours (cells)
    num_cells = len(contours)

    # Display the result
    cv2.putText(result_image, f'Cells: {num_cells}', (10, 30), cv2.FONT_HERSHEY_SIMPLEX, 0.8, (0, 0, 255), 2)
    cv2_imshow(result_image)

    return num_cells

# Example usage
image_path = 'cell.jpg'

# Preprocess the image
preprocessed_image = preprocess_image(image_path)

# Count cells in the preprocessed image
num_cells = count_cells(preprocessed_image)
print(f'Number of cells: {num_cells}')

from google.colab.patches import cv2_imshow
import cv2
import numpy as np

def preprocess_image(image_path):
    # Read the image
    image = cv2.imread(image_path)

    # Convert the image to grayscale
    gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)

    # Apply bilateral filtering for denoising
    denoised = cv2.bilateralFilter(gray, 9, 75, 75)

    # Adaptive histogram equalization
    clahe = cv2.createCLAHE(clipLimit=2.0, tileGridSize=(8, 8))
    equalized = clahe.apply(denoised)

    return equalized

def count_cells(image):
    # Threshold the preprocessed image to get a binary image
    _, thresh = cv2.threshold(image, 200, 255, cv2.THRESH_BINARY)

    # Find contours in the binary image
    contours, _ = cv2.findContours(thresh.copy(), cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)

    # Draw contours on the original image (for visualization)
    result_image = cv2.cvtColor(image, cv2.COLOR_GRAY2BGR)  # Convert grayscale image to color for drawing contours
    cv2.drawContours(result_image, contours, -1, (0, 255, 0), 2)

    # Count the number of contours (cells)
    num_cells = len(contours)

    # Display the result
    cv2.putText(result_image, f'Cells: {num_cells}', (10, 30), cv2.FONT_HERSHEY_SIMPLEX, 0.8, (0, 0, 255), 2)
    cv2_imshow(result_image)

    return num_cells

# Example usage
image_path = 'cell.jpg'

# Preprocess the image
preprocessed_image = preprocess_image(image_path)

# Count cells in the preprocessed image
num_cells = count_cells(preprocessed_image)
print(f'Number of cells: {num_cells}')

from google.colab.patches import cv2_imshow
import cv2
import numpy as np

def preprocess_image(image_path):
    # Read the image
    image = cv2.imread(image_path)

    # Convert the image to grayscale
    gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)

    # Denoising using Non-Local Means Denoising
    denoised = cv2.fastNlMeansDenoising(gray, None, h=10, templateWindowSize=7, searchWindowSize=21)

    # Smoothing using Gaussian Blur
    smoothed = cv2.GaussianBlur(denoised, (11, 11), 0)

    # Histogram Equalization
    equalized = cv2.equalizeHist(smoothed)

    return equalized

def count_cells(image):
    # Adaptive thresholding to create a binary image
    thresh = cv2.adaptiveThreshold(image, 255, cv2.ADAPTIVE_THRESH_MEAN_C, cv2.THRESH_BINARY_INV, 11, 2)

    # Find contours in the binary image
    contours, _ = cv2.findContours(thresh, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)

    # Draw contours on the original image (for visualization)
    result_image = cv2.cvtColor(image, cv2.COLOR_GRAY2BGR)  # Convert grayscale image to color for drawing contours
    cv2.drawContours(result_image, contours, -1, (0, 255, 0), 2)

    # Count the number of contours (cells)
    num_cells = len(contours)

    # Display the result
    cv2.putText(result_image, f'Cells: {num_cells}', (10, 30), cv2.FONT_HERSHEY_SIMPLEX, 0.8, (0, 0, 255), 2)
    cv2_imshow(result_image)

    return num_cells

# Example usage
image_path = 'cell.jpg'

# Preprocess the image
preprocessed_image = preprocess_image(image_path)

# Count cells in the preprocessed image
num_cells = count_cells(preprocessed_image)
print(f'Number of cells: {num_cells}')

from google.colab.patches import cv2_imshow
import cv2
import numpy as np

def preprocess_image(image_path):
    # Read the image
    image = cv2.imread(image_path)

    # Convert the image to grayscale
    gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)

    # Denoising using Non-Local Means Denoising
    denoised = cv2.fastNlMeansDenoising(gray, None, h=10, templateWindowSize=7, searchWindowSize=21)

    # Smoothing using Gaussian Blur
    smoothed = cv2.GaussianBlur(denoised, (11, 11), 0)

    # Histogram Equalization
    equalized = cv2.equalizeHist(smoothed)

    return equalized

def threshold_image(image, method='binary', **kwargs):
    if method == 'binary':
        # Binary thresholding
        _, thresh = cv2.threshold(image, kwargs.get('threshold', 200), 255, cv2.THRESH_BINARY)
    elif method == 'adaptive_mean':
        # Adaptive mean thresholding
        thresh = cv2.adaptiveThreshold(image, 255, cv2.ADAPTIVE_THRESH_MEAN_C, cv2.THRESH_BINARY, kwargs.get('block_size', 11), kwargs.get('C', 2))
    elif method == 'adaptive_gaussian':
        # Adaptive Gaussian thresholding
        thresh = cv2.adaptiveThreshold(image, 255, cv2.ADAPTIVE_THRESH_GAUSSIAN_C, cv2.THRESH_BINARY, kwargs.get('block_size', 11), kwargs.get('C', 2))
    else:
        raise ValueError("Invalid thresholding method")

    return thresh

def count_cells(image):
    # Find contours in the binary image
    contours, _ = cv2.findContours(image, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)

    # Draw contours on the original image (for visualization)
    result_image = cv2.cvtColor(image, cv2.COLOR_GRAY2BGR)  # Convert grayscale image to color for drawing contours
    cv2.drawContours(result_image, contours, -1, (0, 255, 0), 2)

    # Count the number of contours (cells)
    num_cells = len(contours)

    # Display the result
    cv2.putText(result_image, f'Cells: {num_cells}', (10, 30), cv2.FONT_HERSHEY_SIMPLEX, 0.8, (0, 0, 255), 2)
    cv2_imshow(result_image)

    return num_cells

# Example usage
image_path = 'cell.jpg'

# Preprocess the image
preprocessed_image = preprocess_image(image_path)

# Thresholding methods to try
threshold_methods = ['binary', 'adaptive_mean', 'adaptive_gaussian']

for method in threshold_methods:
    print(f"Thresholding Method: {method}")
    # Threshold the preprocessed image
    thresholded_image = threshold_image(preprocessed_image, method=method)

    # Count cells in the thresholded image
    num_cells = count_cells(thresholded_image)
    print(f'Number of cells: {num_cells}')

from google.colab.patches import cv2_imshow
import cv2
import numpy as np

def preprocess_image(image_path):
    # Read the image
    image = cv2.imread(image_path)

    # Convert the image to grayscale
    gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)

    # Denoising using Non-Local Means Denoising
    denoised = cv2.fastNlMeansDenoising(gray, None, h=10, templateWindowSize=7, searchWindowSize=21)

    # Smoothing using Gaussian Blur
    smoothed = cv2.GaussianBlur(denoised, (11, 11), 0)

    # Histogram Equalization
    equalized = cv2.equalizeHist(smoothed)

    return equalized

def threshold_image(image):
    # Otsu's thresholding
    _, thresh = cv2.threshold(image, 0, 255, cv2.THRESH_BINARY + cv2.THRESH_OTSU)
    return thresh

def count_cells(image):
    # Find contours in the binary image
    contours, _ = cv2.findContours(image, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)

    # Draw contours on the original image (for visualization)
    result_image = cv2.cvtColor(image, cv2.COLOR_GRAY2BGR)  # Convert grayscale image to color for drawing contours
    cv2.drawContours(result_image, contours, -1, (0, 255, 0), 2)

    # Count the number of contours (cells)
    num_cells = len(contours)

    # Display the result
    cv2.putText(result_image, f'Cells: {num_cells}', (10, 30), cv2.FONT_HERSHEY_SIMPLEX, 0.8, (0, 0, 255), 2)
    cv2_imshow(result_image)

    return num_cells

# Example usage
image_path = 'cell.jpg'

# Preprocess the image
preprocessed_image = preprocess_image(image_path)

# Threshold the preprocessed image
thresholded_image = threshold_image(preprocessed_image)

# Count cells in the thresholded image
num_cells = count_cells(thresholded_image)
print(f'Number of cells: {num_cells}')

from google.colab.patches import cv2_imshow
import cv2
import numpy as np

def preprocess_image(image_path):
    # Read the image
    image = cv2.imread(image_path)

    # Convert the image to grayscale
    gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)

    # Denoising using Non-Local Means Denoising
    denoised = cv2.fastNlMeansDenoising(gray, None, h=10, templateWindowSize=7, searchWindowSize=21)

    # Smoothing using Gaussian Blur
    smoothed = cv2.GaussianBlur(denoised, (11, 11), 0)

    # Histogram Equalization
    equalized = cv2.equalizeHist(smoothed)

    return equalized

def threshold_image(image, block_size=11, C=2):
    # Adaptive thresholding with Gaussian Mean
    thresh = cv2.adaptiveThreshold(image, 255, cv2.ADAPTIVE_THRESH_GAUSSIAN_C, cv2.THRESH_BINARY, block_size, C)
    return thresh

def count_cells(image):
    # Find contours in the binary image
    contours, _ = cv2.findContours(image, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)

    # Draw contours on the original image (for visualization)
    result_image = cv2.cvtColor(image, cv2.COLOR_GRAY2BGR)  # Convert grayscale image to color for drawing contours
    cv2.drawContours(result_image, contours, -1, (0, 255, 0), 2)

    # Count the number of contours (cells)
    num_cells = len(contours)

    # Display the result
    cv2.putText(result_image, f'Cells: {num_cells}', (10, 30), cv2.FONT_HERSHEY_SIMPLEX, 0.8, (0, 0, 255), 2)
    cv2_imshow(result_image)

    return num_cells

# Example usage
image_path = 'cell.jpg'

# Preprocess the image
preprocessed_image = preprocess_image(image_path)

# Threshold the preprocessed image
thresholded_image = threshold_image(preprocessed_image)

# Count cells in the thresholded image
num_cells = count_cells(thresholded_image)
print(f'Number of cells: {num_cells}')

from google.colab.patches import cv2_imshow
import cv2
import numpy as np

def preprocess_image(image_path):
    # Read the image
    image = cv2.imread(image_path)

    # Convert the image to grayscale
    gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)

    # Denoising using Non-Local Means Denoising
    denoised = cv2.fastNlMeansDenoising(gray, None, h=10, templateWindowSize=7, searchWindowSize=21)

    # Smoothing using Gaussian Blur
    smoothed = cv2.GaussianBlur(denoised, (11, 11), 0)

    # Histogram Equalization
    equalized = cv2.equalizeHist(smoothed)

    return equalized

def adaptive_threshold_image(image, block_size=11, C=2):
    # Adaptive thresholding with Gaussian Mean
    thresh = cv2.adaptiveThreshold(image, 255, cv2.ADAPTIVE_THRESH_GAUSSIAN_C, cv2.THRESH_BINARY, block_size, C)
    return thresh

def post_process_image(image):
    # Morphological operations (closing)
    kernel = np.ones((5, 5), np.uint8)
    closing = cv2.morphologyEx(image, cv2.MORPH_CLOSE, kernel)

    # Morphological operations (opening)
    opening = cv2.morphologyEx(closing, cv2.MORPH_OPEN, kernel)

    return opening

def count_cells(image):
    # Find contours in the binary image
    contours, _ = cv2.findContours(image, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)

    # Draw contours on the original image (for visualization)
    result_image = cv2.cvtColor(image, cv2.COLOR_GRAY2BGR)  # Convert grayscale image to color for drawing contours
    cv2.drawContours(result_image, contours, -1, (0, 255, 0), 2)

    # Count the number of contours (cells)
    num_cells = len(contours)

    # Display the result
    cv2.putText(result_image, f'Cells: {num_cells}', (10, 30), cv2.FONT_HERSHEY_SIMPLEX, 0.8, (0, 0, 255), 2)
    cv2_imshow(result_image)

    return num_cells

# Example usage
image_path = 'cell.jpg'

# Preprocess the image
preprocessed_image = preprocess_image(image_path)

# Adaptive threshold the preprocessed image
adaptive_thresholded_image = adaptive_threshold_image(preprocessed_image)

# Post-process the thresholded image
post_processed_image = post_process_image(adaptive_thresholded_image)

# Count cells in the post-processed image
num_cells = count_cells(post_processed_image)
print(f'Number of cells: {num_cells}')



from google.colab.patches import cv2_imshow
import cv2
import numpy as np

def preprocess_image(image_path):
    # Read the image
    image = cv2.imread(image_path)

    # Convert the image to grayscale
    gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)

    # Denoising using Non-Local Means Denoising
    denoised = cv2.fastNlMeansDenoising(gray, None, h=10, templateWindowSize=7, searchWindowSize=21)

    # Apply Contrast Limited Adaptive Histogram Equalization (CLAHE)
    clahe = cv2.createCLAHE(clipLimit=2.0, tileGridSize=(8, 8))
    equalized = clahe.apply(denoised)

    return equalized

def adaptive_threshold_image(image, block_size=11, C=2):
    # Adaptive thresholding with Gaussian Mean
    thresh = cv2.adaptiveThreshold(image, 255, cv2.ADAPTIVE_THRESH_GAUSSIAN_C, cv2.THRESH_BINARY, block_size, C)
    return thresh

def post_process_image(image):
    # Morphological operations (closing)
    kernel = np.ones((5, 5), np.uint8)
    closing = cv2.morphologyEx(image, cv2.MORPH_CLOSE, kernel)

    # Morphological operations (opening)
    opening = cv2.morphologyEx(closing, cv2.MORPH_OPEN, kernel)

    return opening

def count_cells(image):
    # Find contours in the binary image
    contours, _ = cv2.findContours(image, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)

    # Draw contours on the original image (for visualization)
    result_image = cv2.cvtColor(image, cv2.COLOR_GRAY2BGR)  # Convert grayscale image to color for drawing contours
    cv2.drawContours(result_image, contours, -1, (0, 255, 0), 2)

    # Count the number of contours (cells)
    num_cells = len(contours)

    # Display the result
    cv2.putText(result_image, f'Cells: {num_cells}', (10, 30), cv2.FONT_HERSHEY_SIMPLEX, 0.8, (0, 0, 255), 2)
    cv2_imshow(result_image)

    return num_cells

# Example usage
image_path = 'cell.jpg'

# Preprocess the image using CLAHE
preprocessed_image = preprocess_image(image_path)

# Adaptive threshold the preprocessed image
adaptive_thresholded_image = adaptive_threshold_image(preprocessed_image)

# Post-process the thresholded image
post_processed_image = post_process_image(adaptive_thresholded_image)

# Count cells in the post-processed image
num_cells = count_cells(post_processed_image)
print(f'Number of cells: {num_cells}')

from google.colab.patches import cv2_imshow
import cv2
import numpy as np

def preprocess_image(image_path):
    # Read the image
    image = cv2.imread(image_path)

    # Convert the image to grayscale
    gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)

    # Denoising using Non-Local Means Denoising
    denoised = cv2.fastNlMeansDenoising(gray, None, h=10, templateWindowSize=7, searchWindowSize=21)

    # Apply Contrast Limited Adaptive Histogram Equalization (CLAHE)
    clahe = cv2.createCLAHE(clipLimit=2.0, tileGridSize=(8, 8))
    equalized = clahe.apply(denoised)

    return equalized

def adaptive_threshold_image(image, block_size=11, C=2):
    # Adaptive thresholding with Gaussian Mean
    thresh = cv2.adaptiveThreshold(image, 255, cv2.ADAPTIVE_THRESH_GAUSSIAN_C, cv2.THRESH_BINARY, block_size, C)
    return thresh

def post_process_image(image):
    # Morphological operations (opening and closing)
    kernel = np.ones((5, 5), np.uint8)
    opening = cv2.morphologyEx(image, cv2.MORPH_OPEN, kernel)
    closing = cv2.morphologyEx(opening, cv2.MORPH_CLOSE, kernel)

    return closing

def count_cells(image):
    # Find contours in the binary image
    contours, _ = cv2.findContours(image, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)

    # Draw contours on the original image (for visualization)
    result_image = cv2.cvtColor(image, cv2.COLOR_GRAY2BGR)  # Convert grayscale image to color for drawing contours
    cv2.drawContours(result_image, contours, -1, (0, 255, 0), 2)

    # Count the number of contours (cells)
    num_cells = len(contours)

    # Display the result
    cv2.putText(result_image, f'Cells: {num_cells}', (10, 30), cv2.FONT_HERSHEY_SIMPLEX, 0.8, (0, 0, 255), 2)
    cv2_imshow(result_image)

    return num_cells

# Example usage
image_path = 'cell.jpg'

# Preprocess the image
preprocessed_image = preprocess_image(image_path)

# Adaptive threshold the preprocessed image
adaptive_thresholded_image = adaptive_threshold_image(preprocessed_image)

# Post-process the thresholded image
post_processed_image = post_process_image(adaptive_thresholded_image)

# Count cells in the post-processed image
num_cells = count_cells(post_processed_image)
print(f'Number of cells: {num_cells}')

from google.colab.patches import cv2_imshow
import cv2
import numpy as np

def preprocess_image(image_path):
    # Read the image
    image = cv2.imread(image_path)

    # Convert the image to grayscale
    gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)

    # Denoising using Non-Local Means Denoising
    denoised = cv2.fastNlMeansDenoising(gray, None, h=10, templateWindowSize=7, searchWindowSize=21)

    # Apply Contrast Limited Adaptive Histogram Equalization (CLAHE)
    clahe = cv2.createCLAHE(clipLimit=2.0, tileGridSize=(8, 8))
    equalized = clahe.apply(denoised)

    return equalized

def adaptive_threshold_image(image, block_size=11, C=2):
    # Adaptive thresholding with Gaussian Mean
    thresh = cv2.adaptiveThreshold(image, 255, cv2.ADAPTIVE_THRESH_GAUSSIAN_C, cv2.THRESH_BINARY, block_size, C)
    return thresh

def post_process_image(image):
    # Connected component analysis (connected components labeling)
    num_labels, labeled_image = cv2.connectedComponents(image)

    # Keep only the connected components (regions) larger than a threshold area (e.g., 100 pixels)
    min_area_threshold = 100
    cleaned_image = np.zeros_like(image)
    for label in range(1, num_labels):  # Skip background label (0)
        region_mask = (labeled_image == label).astype(np.uint8)
        region_area = np.sum(region_mask)
        if region_area >= min_area_threshold:
            cleaned_image += region_mask * label

    # Apply binary thresholding to get final binary image
    _, final_image = cv2.threshold(cleaned_image, 0, 255, cv2.THRESH_BINARY)

    return final_image

def count_cells(image):
    # Find contours in the binary image
    contours, _ = cv2.findContours(image, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)

    # Draw contours on the original image (for visualization)
    result_image = cv2.cvtColor(image, cv2.COLOR_GRAY2BGR)  # Convert grayscale image to color for drawing contours
    cv2.drawContours(result_image, contours, -1, (0, 255, 0), 2)

    # Count the number of contours (cells)
    num_cells = len(contours)

    # Display the result
    cv2.putText(result_image, f'Cells: {num_cells}', (10, 30), cv2.FONT_HERSHEY_SIMPLEX, 0.8, (0, 0, 255), 2)
    cv2_imshow(result_image)

    return num_cells

# Example usage
image_path = 'cell.jpg'

# Preprocess the image
preprocessed_image = preprocess_image(image_path)

# Adaptive threshold the preprocessed image
adaptive_thresholded_image = adaptive_threshold_image(preprocessed_image)

# Post-process the thresholded image
post_processed_image = post_process_image(adaptive_thresholded_image)

# Count cells in the post-processed image
num_cells = count_cells(post_processed_image)
print(f'Number of cells: {num_cells}')